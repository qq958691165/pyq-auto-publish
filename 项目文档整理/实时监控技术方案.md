# 实时监控技术方案

## 📊 方案对比

| 方案 | 技术 | 实时性 | 成本 | 难度 | 推荐度 |
|------|------|--------|------|------|--------|
| **方案一** | we-mp-rss Webhook | ⭐⭐⭐⭐⭐ 秒级 | 免费 | ⭐⭐ 简单 | ⭐⭐⭐⭐⭐ |
| **方案二** | 定时轮询 | ⭐⭐⭐ 分钟级 | 免费 | ⭐ 简单 | ⭐⭐⭐ |
| **方案三** | WebSocket实时推送 | ⭐⭐⭐⭐⭐ 秒级 | 免费 | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐ |

---

## 🎯 方案一: we-mp-rss Webhook (推荐)

### 核心原理
we-mp-rss已经内置了Webhook功能,当检测到新文章时会自动推送到我们的后端服务器。

### 技术流程
```
公众号发布新文章
  ↓
we-mp-rss自动检测到新文章
  ↓
we-mp-rss调用我们的Webhook接口
  ↓
后端接收到新文章数据
  ↓
自动触发处理流程:
  1. 保存到飞书多维表格
  2. 调用Coze工作流改写文案
  3. 下载图片到本地
  4. 调用Puppeteer发布到堆雪球
  ↓
前端通过WebSocket实时收到通知
  ↓
前端页面自动刷新显示新文章
```

### 实现步骤

#### 1️⃣ 配置we-mp-rss Webhook
在we-mp-rss的"配置信息"页面设置Webhook URL:
```
http://你的服务器IP:3000/api/wechat-monitor/webhook
```

#### 2️⃣ 后端已实现Webhook接收接口
文件: `pyq-backend/src/wechat-monitor/wechat-monitor.controller.ts`
```typescript
@Post('webhook')
async handleWebhook(@Body() articleData: any) {
  return this.wechatMonitorService.handleArticleWebhook(articleData);
}
```

#### 3️⃣ 自动化处理流程
文件: `pyq-backend/src/wechat-monitor/wechat-monitor.service.ts`
- ✅ 提取文章数据(标题、正文、图片、发布时间)
- ✅ 保存到飞书多维表格
- ✅ 调用Coze工作流改写文案
- ✅ 下载图片到本地
- ✅ 调用Puppeteer发布到堆雪球

#### 4️⃣ 前端实时通知
使用WebSocket推送新文章通知到前端页面

### 优势
- ✅ **实时性最强** - 秒级响应,公众号发布后立即收到通知
- ✅ **完全自动化** - 无需人工干预,全流程自动完成
- ✅ **资源消耗低** - 被动接收推送,不需要定时轮询
- ✅ **已有基础** - we-mp-rss已支持Webhook,只需配置即可

### 需要配置的环境变量
在 `.env` 文件中添加:
```env
# 飞书配置
FEISHU_APP_ID=你的飞书应用ID
FEISHU_APP_SECRET=你的飞书应用密钥
FEISHU_TABLE_ID=你的飞书多维表格ID

# Coze配置
COZE_API_KEY=你的Coze API密钥
COZE_WORKFLOW_ID=你的Coze工作流ID

# Puppeteer服务配置
PUPPETEER_SERVICE_URL=http://localhost:3002
```

---

## 🔄 方案二: 定时轮询

### 核心原理
后端定时(如每5分钟)调用we-mp-rss API查询是否有新文章。

### 技术实现
```typescript
// 使用NestJS的定时任务
import { Cron } from '@nestjs/schedule';

@Cron('*/5 * * * *') // 每5分钟执行一次
async checkNewArticles() {
  const articles = await this.weMpRssService.getArticles();
  // 检查是否有新文章
  // 如果有,触发处理流程
}
```

### 优势
- ✅ 实现简单
- ✅ 不依赖外部推送

### 劣势
- ❌ 实时性差(5分钟延迟)
- ❌ 资源消耗高(频繁轮询)
- ❌ 可能错过文章(如果轮询间隔内发布多篇)

---

## 🌐 方案三: WebSocket实时推送

### 核心原理
前端通过WebSocket连接后端,后端收到新文章时立即推送到前端。

### 技术实现

#### 后端WebSocket服务
```typescript
import { WebSocketGateway, WebSocketServer } from '@nestjs/websockets';
import { Server } from 'socket.io';

@WebSocketGateway()
export class ArticleGateway {
  @WebSocketServer()
  server: Server;

  // 推送新文章通知
  notifyNewArticle(article: any) {
    this.server.emit('newArticle', article);
  }
}
```

#### 前端WebSocket连接
```javascript
const socket = io('http://localhost:3000');

socket.on('newArticle', (article) => {
  // 显示新文章通知
  showNotification(`新文章: ${article.title}`);
  // 刷新文章列表
  refreshArticleList();
});
```

### 优势
- ✅ 前端实时收到通知
- ✅ 用户体验好
- ✅ 可以显示实时状态

### 劣势
- ❌ 需要额外开发WebSocket服务
- ❌ 需要维护长连接

---

## 🎯 推荐方案: 方案一 + 方案三组合

### 完整技术架构
```
公众号发布新文章
  ↓
we-mp-rss检测到新文章 (实时)
  ↓
调用我们的Webhook接口 (秒级)
  ↓
后端处理文章数据
  ├─ 保存到飞书
  ├─ 调用Coze改写
  ├─ 下载图片
  └─ 发布到堆雪球
  ↓
通过WebSocket推送到前端 (实时)
  ↓
前端显示新文章通知 (实时)
  ↓
用户可以查看处理进度
```

### 实现优先级
1. **第一步**: 配置we-mp-rss Webhook (已完成后端代码)
2. **第二步**: 配置飞书、Coze、Puppeteer环境变量
3. **第三步**: 测试Webhook接收和自动化流程
4. **第四步**: 添加WebSocket实时推送到前端
5. **第五步**: 前端添加实时通知UI

---

## 📋 下一步行动计划

### 立即可做
1. ✅ 在we-mp-rss配置页面设置Webhook URL
2. ✅ 配置.env环境变量(飞书、Coze、Puppeteer)
3. ✅ 测试发布一篇公众号文章,验证Webhook是否触发

### 需要开发
1. ⏳ 完善Puppeteer自动化堆雪球服务
2. ⏳ 添加WebSocket实时推送功能
3. ⏳ 前端添加实时通知UI组件

### 需要配置
1. ⏳ 飞书多维表格创建和配置
2. ⏳ Coze工作流创建和配置
3. ⏳ 服务器部署和域名配置

---

## 🔧 快速启动指南

### 1. 配置we-mp-rss Webhook
1. 打开 http://localhost:8001
2. 点击左侧菜单"配置信息"
3. 找到"Webhook URL"配置项
4. 填入: `http://localhost:3000/api/wechat-monitor/webhook`
5. 保存配置

### 2. 配置环境变量
编辑 `pyq-backend/.env` 文件:
```env
# we-mp-rss配置
WE_MP_RSS_URL=http://localhost:8001
WE_MP_RSS_USERNAME=admin
WE_MP_RSS_PASSWORD=admin@123

# 飞书配置
FEISHU_APP_ID=cli_xxxxxxxxxx
FEISHU_APP_SECRET=xxxxxxxxxx
FEISHU_TABLE_ID=xxxxxxxxxx

# Coze配置
COZE_API_KEY=pat_xxxxxxxxxx
COZE_WORKFLOW_ID=xxxxxxxxxx

# Puppeteer服务配置
PUPPETEER_SERVICE_URL=http://localhost:3002
```

### 3. 重启后端服务
```bash
cd pyq-backend
npm run start:dev
```

### 4. 测试Webhook
在we-mp-rss中订阅一个公众号,等待新文章发布,观察后端日志是否收到Webhook推送。

---

## 🎉 预期效果

### 用户视角
1. 公众号发布新文章
2. 几秒钟后,前端页面右上角弹出通知: "检测到新文章: xxx"
3. 文章列表自动刷新,显示新文章
4. 文章状态显示: "处理中" → "改写完成" → "已发布"
5. 全程无需人工干预

### 技术视角
1. we-mp-rss检测到新文章(实时)
2. 调用Webhook推送到后端(秒级)
3. 后端自动处理(1-2分钟)
4. WebSocket推送到前端(实时)
5. 前端UI实时更新(秒级)

---

## 💡 关键优势

- ✅ **完全自动化** - 从检测到发布全流程自动化
- ✅ **实时响应** - 秒级检测和通知
- ✅ **用户体验好** - 实时通知和状态更新
- ✅ **成本低** - 全部使用免费技术方案
- ✅ **可扩展** - 可以轻松添加更多自动化功能

