# 常见问题与解决方案

[← 返回README](./README.md)

---

## 📋 问题分类

- [部署相关](#-部署相关)
- [功能相关](#-功能相关)
- [性能相关](#-性能相关)
- [Storage相关](#-storage相关)
- [前端相关](#-前端相关)
- [本地开发相关](#-本地开发相关)
- [重大问题深度分析](#-重大问题深度分析)

---

## 🚀 部署相关

### Q1: Node.js版本不对怎么办?

**问题**: 系统提示Node.js版本不匹配

**解决方案**:
```bash
# 使用nvm切换版本
nvm use 20.19.5

# 如果没有安装该版本
nvm install 20.19.5
nvm alias default 20.19.5
```

---

### Q2: PM2服务无法启动?

**问题**: PM2启动后立即退出

**排查步骤**:
```bash
# 1. 查看详细日志
pm2 logs pyq-backend --lines 50

# 2. 检查环境变量
cat /www/wwwroot/pyq-backend/.env

# 3. 检查端口占用
netstat -tlnp | grep :3000

# 4. 手动启动测试
cd /www/wwwroot/pyq-backend
node dist/main.js
```

**常见原因**:
- 环境变量配置错误
- 端口被占用
- 依赖未安装完整
- 数据库连接失败

---

### Q3: 502错误怎么解决?

**问题**: 访问网站显示502 Bad Gateway

**排查步骤**:
```bash
# 1. 检查Node.js服务是否运行
pm2 list

# 2. 检查端口监听
netstat -tlnp | grep :3000

# 3. 查看Nginx错误日志
tail -f /www/wwwlogs/error.log

# 4. 测试后端API
curl http://localhost:3000/api/health
```

**解决方案**:
```bash
# 重启后端服务
pm2 restart pyq-backend

# 重启Nginx
nginx -s reload
```

---

### Q4: 前端更新后浏览器还是显示旧版本? (重要!)

**问题**: 部署新版本后,浏览器仍显示旧页面

**问题原因**:
- Nginx配置的`root`路径与实际部署路径不一致
- 导致浏览器一直加载旧文件

**排查步骤**:
```bash
# 1. 查看Nginx配置文件
cat /www/server/panel/vhost/nginx/node_pyq_backend.conf

# 2. 找到root配置行,例如:
#    root /www/wwwroot/pyq-frontend;

# 3. 确认实际部署路径
ls -lh /www/wwwroot/pyq-frontend/index.html

# 4. 检查index.html引用的JS文件
cat /www/wwwroot/pyq-frontend/index.html | grep "index-"

# 5. 验证浏览器加载的文件
curl https://autochat.lfdhk.com/ | grep "index-"
```

**解决方案**:
```bash
# 方案1: 部署到Nginx配置的正确目录 (推荐)
cd 朋友圈自动发布系统/pyq-frontend-vben
pnpm build:antd
scp -r apps/web-antd/dist/* root@服务器IP:/www/wwwroot/pyq-frontend/

# 方案2: 修改Nginx配置指向新目录
# 编辑 /www/server/panel/vhost/nginx/node_pyq_backend.conf
# 修改 root 路径为实际部署路径
# 然后重启Nginx: nginx -s reload
```

**验证修复**:
```bash
# 1. 清除Nginx缓存
rm -rf /www/server/nginx/proxy_cache_dir/*
nginx -s reload

# 2. 测试是否加载新文件
curl https://autochat.lfdhk.com/ | grep "index-"

# 3. 浏览器强制刷新 (Ctrl+Shift+R)
```

**重要提醒**:
- ⚠️ 部署前必须先检查Nginx配置的root路径
- ⚠️ 不要假设部署路径,一定要查看配置文件确认
- ⚠️ 浏览器缓存不是主要问题,路径错误才是根本原因

---

### Q5: Puppeteer启动失败 - Missing X server

**错误信息**:
```
Error: Missing X server to start the headful browser.
Either set headless to true or use xvfb-run to run your Puppeteer script.
```

**问题现象**:
- 本地测试正常,部署到服务器后无法执行自动发布任务
- 控制台没有任何输出,浏览器没有启动
- 后端日志显示 `Missing X server` 错误

**问题原因**:
- 服务器是**无图形界面的Linux系统**,没有X Server(图形显示服务器)
- 环境变量 `PUPPETEER_HEADLESS=false`,尝试启动有界面的浏览器
- 本地macOS/Windows有图形界面,所以测试正常
- 服务器Linux无图形界面,必须使用无头模式(headless)

**解决方案**:

```bash
# 1. 连接到服务器
ssh root@124.223.35.102

# 2. 修改环境变量
cd /www/wwwroot/pyq-backend
sed -i 's/PUPPETEER_HEADLESS=false/PUPPETEER_HEADLESS=true/' .env

# 3. 验证修改
cat .env | grep PUPPETEER_HEADLESS
# 应该显示: PUPPETEER_HEADLESS=true

# 4. 重启服务
pm2 restart pyq-backend

# 5. 查看日志确认
pm2 logs pyq-backend --lines 20
```

**环境差异对比**:

| 环境 | 图形界面 | PUPPETEER_HEADLESS | 结果 |
|------|---------|-------------------|------|
| **本地macOS** | ✅ 有 | `false` | ✅ 正常运行,显示浏览器窗口 |
| **本地Windows** | ✅ 有 | `false` | ✅ 正常运行,显示浏览器窗口 |
| **服务器Linux** | ❌ 无 | `false` | ❌ 启动失败,Missing X server |
| **服务器Linux** | ❌ 无 | `true` | ✅ 正常运行,无头模式 |

**预防措施**:
- 生产服务器的 `.env` 文件中**必须**设置 `PUPPETEER_HEADLESS=true`
- 本地开发可以使用 `false`,方便调试
- 部署前检查环境变量配置,避免重复踩坑

**相关文档**:
- [部署与配置指南 - Puppeteer配置](./部署与配置指南.md#5-puppeteer配置-重要)

---

## ⚙️ 功能相关

### Q5: 暂停/恢复功能不工作,重复发送消息? (重要!)

**问题**: 脚本2组合发送任务暂停后恢复,系统从第一个好友重新开始发送,导致重复发送

**问题现象**:
- 发送消息给好友A成功
- 点击"暂停"按钮
- 点击"恢复"按钮
- 系统重新从好友A开始发送,而不是跳过已发送的好友
- 数据库`message_send_history`表为空,没有记录

**问题原因**:

**根本原因**: 数据库表`message_send_history`的`friend_id`字段类型错误

- **错误类型**: `friend_id UUID NOT NULL`
- **正确类型**: `friend_id BIGINT NOT NULL`

**错误过程**:
1. 代码中`friend_id`是BIGINT类型(例如299620)
2. 数据库表中`friend_id`是UUID类型
3. 插入数据时,PostgreSQL尝试将BIGINT值解析为UUID
4. 报错:`invalid input syntax for type uuid: "299620"`
5. 插入失败,数据库中没有记录
6. 恢复任务时,`checkMessageSent()`查询不到记录
7. 系统认为所有好友都未发送,从头开始

**解决方案**:

**步骤1: 在Supabase SQL Editor中执行以下SQL**

```sql
-- 1. 删除旧表
DROP TABLE IF EXISTS message_send_history CASCADE;

-- 2. 创建新表(friend_id改为BIGINT类型)
CREATE TABLE message_send_history (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL,
  friend_id BIGINT NOT NULL,  -- ✅ 改为BIGINT类型
  friend_name TEXT NOT NULL,
  message_type TEXT NOT NULL CHECK (message_type IN ('text', 'video', 'link', 'image', 'combined')),
  message_content_hash TEXT NOT NULL,
  message_content JSONB NOT NULL,
  sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  task_id TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3. 创建索引
CREATE INDEX idx_message_send_history_lookup
ON message_send_history(user_id, friend_id, message_content_hash);

CREATE INDEX idx_message_send_history_sent_at
ON message_send_history(sent_at DESC);

CREATE INDEX idx_message_send_history_user_id
ON message_send_history(user_id);
```

**步骤2: 验证修复**

```bash
# 在后端目录执行
node -e "
const { createClient } = require('@supabase/supabase-js');
require('dotenv').config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_KEY
);

(async () => {
  // 测试插入
  const { error } = await supabase
    .from('message_send_history')
    .insert({
      user_id: '2e748b58-8f94-48ba-8a43-a1b0c93ed3a0',
      friend_id: 299620,  // BIGINT类型
      friend_name: '测试好友',
      message_type: 'text',
      message_content_hash: 'test_hash',
      message_content: { text: '测试' }
    });

  if (error) {
    console.error('❌ 插入失败:', error);
  } else {
    console.log('✅ 插入成功!');
  }
})();
"
```

**步骤3: 测试暂停/恢复功能**

1. 发起一个组合发送任务(选择2-3个好友)
2. 等待第1个好友发送成功
3. 点击"暂停"按钮
4. 点击"恢复"按钮
5. 观察系统是否跳过第1个好友,从第2个好友继续

**预防措施**:
- 使用正确的迁移文件:`pyq-backend/supabase/migrations/20251201_create_message_send_history.sql`
- 删除错误的迁移文件:`数据库脚本/create_message_send_history.sql`
- 在Supabase中执行迁移前,先检查表结构

**相关文档**:
- [数据库结构文档 - message_send_history表](./数据库结构文档.md#9-message_send_history-消息发送历史表)
- [脚本2文档 - 防重复发送机制](./脚本2-微信好友触达.md#1-防重复发送机制)

---

### Q6: we-mp-rss登录失效?

**问题**: 公众号文章无法同步

**解决方案**:
```bash
# 重启Docker容器
docker restart we-mp-rss

# 查看容器日志
docker logs we-mp-rss --tail 50

# 重新扫码登录
# 访问 http://服务器IP:8001
# 点击"登录微信公众平台"
```

---

### Q6: 图片无法加载?

**问题**: 公众号文章图片显示失败

**原因**: 微信图片防盗链

**解决方案**: 系统已实现后端图片代理功能,自动处理

**验证**:
```bash
# 检查图片代理接口
curl http://localhost:3000/api/wechat-monitor/proxy-image?url=xxx
```

---

### Q6.1: 多用户隔离后订阅头像和文章图片不显示? (重要!)

**问题**: 实现多用户订阅隔离后,订阅头像显示占位符图片,文章图片无法加载

**问题现象**:
- 订阅列表中的公众号头像显示 `via.placeholder.com/40`
- 浏览器控制台报错: `GET https://via.placeholder.com/40 net::ERR_CONNECTION_CLOSED`
- 点开文章详情,文章中的图片也无法显示
- image-proxy接口返回401 Unauthorized

**问题原因**:

**原因1: 订阅头像为空**
- 修改成从数据库读取订阅后,数据库中的`mp_cover`字段是空的
- 前端收到空的头像URL,显示了占位符图片

**原因2: image-proxy接口需要JWT认证**
- Controller级别使用了`@UseGuards(JwtAuthGuard)`
- image-proxy接口也被强制要求JWT认证
- HTML中的`<img>`标签无法发送Authorization header
- 导致所有图片请求返回401错误

**解决方案**:

**修复1: getSubscriptions方法补充头像信息**

```typescript
// we-mp-rss.service.ts
async getSubscriptions(userId?: string) {
  // 1. 从数据库读取用户订阅
  const { data: userSubscriptions } = await this.supabaseService
    .getClient()
    .from('wechat_subscriptions')
    .select('*')
    .eq('user_id', userId);

  // 2. 从we-mp-rss获取所有订阅(用于补充头像信息)
  const headers = await this.getHeaders();
  const rssResponse = await this.axiosInstance.get('/api/v1/wx/mps', {
    headers,
  });
  const allRssSubscriptions = rssResponse.data?.data?.list || [];

  // 3. 补充头像信息
  const formattedSubscriptions = userSubscriptions.map((sub) => {
    const rssSubscription = allRssSubscriptions.find(
      (rssSub: any) =>
        rssSub.mp_name === sub.mp_name ||
        rssSub.id === sub.standard_mp_id
    );

    const avatar = sub.mp_cover || rssSubscription?.avatar;

    return {
      id: sub.mp_id,
      mp_id: sub.mp_id,
      mp_name: sub.mp_name,
      avatar: avatar,
      mp_cover: avatar,
      mp_intro: sub.mp_intro || rssSubscription?.mp_intro,
    };
  });

  return { success: true, data: { list: formattedSubscriptions } };
}
```

**修复2: 创建@Public()装饰器**

```typescript
// jwt-auth.guard.ts
import { Injectable, ExecutionContext, SetMetadata } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AuthGuard } from '@nestjs/passport';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) {
      return true;
    }
    return super.canActivate(context);
  }
}
```

**修复3: 标记image-proxy为公开接口**

```typescript
// wechat-monitor.controller.ts
import { JwtAuthGuard, Public } from '../auth/jwt-auth.guard';

@Controller('wechat-monitor')
@UseGuards(JwtAuthGuard)
export class WechatMonitorController {
  /**
   * 图片代理 - 解决微信图片跨域问题
   * 注意: 此接口不需要JWT认证,因为图片是在HTML中直接引用的
   */
  @Public()  // ← 标记为公开接口
  @Get('image-proxy')
  async imageProxy(@Query('url') imageUrl: string, @Res() res: Response) {
    // ... 代理逻辑
  }
}
```

**验证修复**:

```bash
# 1. 测试image-proxy接口(不需要JWT token)
curl -I 'http://localhost:3000/api/wechat-monitor/image-proxy?url=https://mmbiz.qpic.cn/test.jpg'
# 应该返回500(图片不存在)而不是401(未授权)

# 2. 刷新浏览器
# Ctrl+Shift+R (Windows/Linux)
# Cmd+Shift+R (Mac)

# 3. 查看订阅列表
# 订阅头像应该正常显示

# 4. 打开文章详情
# 文章中的图片应该正常加载
```

**技术要点**:

1. **多用户隔离的正确实现**:
   - 数据库存储用户订阅关系
   - 查询时从we-mp-rss补充完整信息(头像、简介等)
   - 不能只依赖数据库中的数据

2. **NestJS Guard的正确使用**:
   - `@UseGuards()`空参数**不会**覆盖Controller级别的Guard
   - 必须使用`@Public()`装饰器配合自定义Guard
   - Reflector用于读取装饰器元数据

3. **图片代理的认证策略**:
   - HTML `<img>`标签无法发送自定义header
   - 图片代理接口必须允许公开访问
   - 可以通过其他方式限制访问(如IP白名单、Referer检查)

**相关问题**:
- 如果遇到订阅隔离问题,参考"Q11: 多用户订阅隔离实现"
- 如果遇到CORS问题,检查image-proxy的响应头设置

---

### Q7: Coze API返回"in_progress"?

**问题**: AI改写一直处于进行中状态

**原因**: Coze Bot处理耗时较长

**解决方案**: 系统已实现轮询机制,会自动等待结果

**配置**:
```typescript
// 轮询间隔: 2秒
// 最大等待时间: 60秒
// 超时后返回错误
```

---

### Q8: 堆雪球自动化失败?

**问题**: Puppeteer无法操作堆雪球系统

**排查步骤**:
```bash
# 1. 检查堆雪球账号密码
cat /www/wwwroot/pyq-backend/.env | grep DUIXUEQIU

# 2. 查看Puppeteer日志
pm2 logs pyq-backend | grep Puppeteer

# 3. 测试手动登录
# 访问 https://dxqscrm.duixueqiu.cn/
```

**常见原因**:
- 账号密码错误
- 堆雪球页面结构变化
- 网络连接问题
- Puppeteer超时

---

### Q9: 视频号/链接素材发送失败,浏览器突然关闭?

**问题**: 脚本2组合发送时,视频号或链接素材正确选择了,点击"确定"后浏览器突然关闭

**现象**:
```
📹 发送视频号素材...
🔍 开始搜索匹配的素材(优先缩略图URL,备用作者名+描述)...
📄 搜索第 1 页...
⚠️ 第1页未找到匹配素材 (共20个素材)
❌ 直接发送视频号失败: 未找到匹配的素材(缩略图URL)
❌ 视频号素材发送失败
[浏览器关闭]
```

**根本原因**:

数据库中的素材信息与堆雪球系统中的素材库不同步,导致匹配失败:
- **视频号素材**: 缩略图URL不匹配
- **链接素材**: 标题或公众号名称不匹配

**解决方案**:

系统已在V5.6版本实现**双重匹配机制**,大幅提高匹配成功率:

**1. 视频号素材双重匹配**
- **优先**: 缩略图URL精确匹配
- **备用**: 作者名+描述文字匹配(前20字符)

```typescript
// 匹配逻辑
const thumbnailMatch = thumbnailUrl === targetThumbnail;
const textMatch = authorName === targetAuthor && contentDesc.includes(targetDesc.substring(0, 20));

if (thumbnailMatch || textMatch) {
  // 匹配成功
}
```

**2. 链接素材双重匹配**
- **优先**: 标题+公众号名称精确匹配
- **备用**: 标题前30字符+公众号名称模糊匹配

```typescript
// 匹配逻辑
const exactMatch = title === targetTitle && accountName === targetAccount;
const fuzzyMatch = title.substring(0, 30) === targetTitle.substring(0, 30) && accountName === targetAccount;

if (exactMatch || fuzzyMatch) {
  // 匹配成功
}
```

**3. 如果仍然失败,重新同步素材库**

```bash
# 前端操作
1. 进入"脚本2 - 组合发送"页面
2. 点击"同步视频号素材"按钮
3. 点击"同步链接素材"按钮
4. 等待同步完成
5. 重新测试发送功能
```

**日志输出**:
```
✅ 找到匹配的素材: 作者名 - 描述...
🔍 匹配方式: 缩略图URL / 作者名+描述 / 精确匹配 / 模糊匹配(前30字符)
```

**预防措施**:
- 定期同步素材库(建议每周一次)
- 发送前先测试一个好友,确认素材匹配成功
- 查看日志中的匹配方式,了解匹配情况

---

### Q10: 如何使用随机延迟功能避免被检测为机器人?

**问题**: 大批量发送消息时,担心被微信检测为机器人

**解决方案**: 使用随机延迟功能,模拟真人操作

**配置步骤**:

1. **进入脚本2页面**
   - 访问: http://localhost:4173/ (本地) 或 https://your-domain.com (生产)
   - 点击"脚本2 - 组合发送"

2. **找到"发送策略配置"卡片**
   - 位置: 在"内容配置"和"发送进度"之间

3. **启用随机延迟**
   - 勾选"启用随机延迟"复选框
   - 设置最小延迟时间(秒): 默认3秒,可调整1-60秒
   - 设置最大延迟时间(秒): 默认10秒,可调整1-60秒
   - 实时提示会显示: "每条消息间隔 3-10 秒"

4. **开始发送任务**
   - 配置好其他选项(好友、内容等)
   - 点击"开始发送"按钮

**工作原理**:

```typescript
// 在每条消息发送前添加随机延迟(除了第一条)
for (let i = 0; i < messages.length; i++) {
  // 第一条消息立即发送,后续消息添加随机延迟
  if (i > 0 && randomDelay?.enabled) {
    const minDelay = randomDelay.minDelay || 3;
    const maxDelay = randomDelay.maxDelay || 10;
    const delay = minDelay + Math.random() * (maxDelay - minDelay);

    // 等待随机时间
    await new Promise(resolve => setTimeout(resolve, delay * 1000));
  }

  // 发送消息
  await sendMessage(messages[i]);
}
```

**日志输出**:
```
💬 发送文字消息...
✅ text消息已发送并记录
⏳ 随机延迟: 7.3 秒...
📹 发送视频号素材...
✅ video消息已发送并记录
⏳ 随机延迟: 4.8 秒...
🔗 发送链接素材...
✅ link消息已发送并记录
```

**推荐配置**:

| 场景 | 最小延迟 | 最大延迟 | 说明 |
|------|---------|---------|------|
| **测试环境** | 1秒 | 3秒 | 快速测试,节省时间 |
| **小批量发送** (< 100人) | 3秒 | 10秒 | 正常发送,避免过快 |
| **中批量发送** (100-500人) | 5秒 | 15秒 | 增加延迟,更安全 |
| **大批量发送** (> 500人) | 10秒 | 30秒 | 高峰期使用,最安全 |

**注意事项**:
- 延迟时间越长,发送速度越慢,但越安全
- 建议根据实际情况调整,避免过度延迟
- 可以先小批量测试,观察效果后再大批量发送

---

### Q11: 好友同步时微信号切换失败?

**问题**: 点击"1号机"同步好友,实际同步的是"10号机"的数据

**现象**:
```
✅ 已点击微信号: 1号机
✅ 好友数据已更新! 从 0 变为 9948  ❌ 错误的好友数
🔍 当前选中的微信号: 沪港纪老板(10号机)  ❌ 错误的微信号
```

**根本原因**:

堆雪球使用Vue.js框架,微信号列表的点击事件通过Vue的`@click`监听器处理。Puppeteer的`element.click()`方法只能触发DOM的`onclick`属性,无法触发Vue的事件监听器,导致:
- ✅ CSS的`.selected`类正确应用(样式改变)
- ❌ Vue的数据状态未更新(实际选中的还是之前的微信号)

**排查步骤**:

```bash
# 1. 查看后端日志,确认问题
pm2 logs pyq-backend --lines 100 | grep "当前选中的微信号"

# 2. 检查是否有"微信号不匹配"的警告
pm2 logs pyq-backend --lines 100 | grep "微信号不匹配"

# 3. 查看重试次数
pm2 logs pyq-backend --lines 100 | grep "第.*次尝试"
```

**解决方案**:

系统已在V5.5.2版本修复此问题,采用以下方案:

**1. 使用dispatchEvent模拟真实鼠标事件**
```typescript
// ❌ 错误方式 - 不触发Vue事件
(item as HTMLElement).click();

// ✅ 正确方式 - 触发Vue事件
const clickEvent = new MouseEvent('click', {
  view: window,
  bubbles: true,
  cancelable: true
});
item.dispatchEvent(clickEvent);
```

**2. 双重验证机制**
```typescript
// 不仅检查CSS样式,还验证Vue数据状态
const result = await page.evaluate(() => {
  // 获取好友数
  let friendCount = 0;
  // 获取当前选中的微信号名称
  let selectedAccount = '';
  return { friendCount, selectedAccount };
});

// 验证:好友数>0 且 选中的微信号名称正确
if (result.friendCount > 0 && result.selectedAccount === accountName) {
  // 验证通过
} else {
  // 触发重试
}
```

**3. 自动重试机制**
- 最多重试5次
- 每次重试间隔2秒
- 验证通过后立即停止

**修复效果**:
```
🔄 第 3 次尝试点击微信号: 1号机
✅ 好友数据已更新! 好友数: 6396, 选中微信号: 1号机  ✅ 正确!
📊 已收集 275 个好友... (滚动次数: 50)
📊 已收集 2648 个好友... (滚动次数: 500)
```

**技术要点**:
- Vue.js/React等框架的事件监听器需要使用`dispatchEvent`触发
- 不能只检查CSS样式,必须验证框架的数据状态
- 自动重试机制提高成功率

**适用场景**:
- 所有使用Vue.js/React等框架的SPA应用
- Puppeteer自动化需要触发框架事件的场景

---

### Q10: 好友同步只同步了一部分?

**问题**: 6396个好友只同步了28个就停止了

**原因**: 滚动加载参数设置不合理

**排查步骤**:
```bash
# 查看滚动日志
pm2 logs pyq-backend --lines 200 | grep "已收集.*个好友"

# 检查是否提前停止
pm2 logs pyq-backend --lines 200 | grep "滚动.*次"
```

**解决方案**:

系统已在V5.5.2版本优化滚动参数:

```typescript
// 修复前
const maxScrollAttempts = 2000;  // 最大滚动2000次
const stableCount = 10;          // 连续10次(5秒)不变就停止

// 修复后
const maxScrollAttempts = 5000;  // 最大滚动5000次
const stableCount = 100;         // 连续100次(50秒)不变才停止
```

**计算依据**:
- 每次滚动加载约2-5个好友
- 6396个好友需要约3200次滚动
- 设置5000次确保有足够余量
- 连续50秒不变说明已经到底

**验证修复**:
```bash
# 查看滚动进度
pm2 logs pyq-backend --lines 50 | grep "已收集"

# 应该看到类似输出:
# 📊 已收集 275 个好友... (滚动次数: 50)
# 📊 已收集 544 个好友... (滚动次数: 100)
# 📊 已收集 2648 个好友... (滚动次数: 500)
```

---

### Q11: 好友列表只能加载1000条? (重要!)

**问题**: 打开好友列表管理弹窗时,只能显示1000个好友,无法加载全部好友

**问题现象**:
- 数据库中有113,351个好友
- 前端只显示1000个好友
- 或者显示"正在加载"后超时失败
- 控制台报错: `canceling statement due to statement timeout`

**问题原因**:

**原因1: Supabase PostgREST的max-rows限制**
- Supabase默认限制每次API查询最多返回1000条数据
- 这是PostgREST的安全限制,防止恶意请求或意外查询大量数据
- 即使后端代码设置了更大的limit,也会被Supabase截断

**原因2: 后端分页查询参数不合理**
- 如果每次查询太多数据(如199000条),会触发PostgreSQL的statement timeout
- 如果每次查询太少数据(如999条),需要多次查询,速度慢

**解决方案**:

**步骤1: 修改Supabase max-rows限制**

1. 访问Supabase Dashboard: https://supabase.com/dashboard
2. 登录并进入项目(pyq-system)
3. 点击左侧菜单 **Project Settings** → **Data API**
4. 找到 **Max rows** 设置(默认1000)
5. 修改为 **200000** (足够容纳所有好友数据)
6. 点击 **Save** 保存

**步骤2: 调整后端分页查询大小**

修改文件: `pyq-backend/src/automation/duixueqiu-friends.service.ts`

```typescript
async getFriends(userId: string): Promise<any[]> {
  let allData = [];
  let start = 0;
  const limit = 10000;  // 每次查询10000条,平衡速度和稳定性

  while (true) {
    const { data, error } = await this.supabaseService.getClient()
      .from('duixueqiu_friends')
      .select('*')
      .eq('user_id', userId)
      .order('friend_name', { ascending: true })
      .range(start, start + limit - 1);

    if (error) {
      this.logger.error(`获取好友列表失败: ${error.message}`);
      throw error;
    }

    if (!data || data.length === 0) break;

    allData = allData.concat(data);

    // 如果返回的数据少于limit,说明已经是最后一页
    if (data.length < limit) break;

    start += limit;
  }

  this.logger.log(`获取好友列表成功: 共 ${allData.length} 个好友`);
  return allData;
}
```

**步骤3: 重启后端服务**

```bash
# 本地开发环境
cd 朋友圈自动发布系统/pyq-backend
npm run start:dev

# 生产环境
ssh root@124.223.35.102
pm2 restart pyq-backend
```

**步骤4: 验证修复**

1. 刷新浏览器 (Ctrl+R 或 Cmd+R)
2. 重新打开好友列表管理弹窗
3. 应该能看到所有113,351个好友

**分页查询参数选择建议**:

| limit值 | 查询次数 | 速度 | 稳定性 | 推荐 |
|---------|---------|------|--------|------|
| 999 | ~114次 | 慢 | ✅ 高 | ❌ 太慢 |
| 5000 | ~23次 | 中 | ✅ 高 | ✅ 可选 |
| 10000 | ~12次 | 快 | ✅ 高 | ✅ **推荐** |
| 20000 | ~6次 | 很快 | ⚠️ 中 | ⚠️ 可能超时 |
| 199000 | 1次 | 最快 | ❌ 低 | ❌ 会超时 |

**技术要点**:

1. **Supabase max-rows是硬限制**:
   - 无论后端代码如何设置,都会被Supabase截断
   - 必须在Supabase Dashboard中修改配置

2. **分页查询是必须的**:
   - 即使提升了max-rows限制,一次性查询10万+数据仍会超时
   - 使用循环分页查询,每次10000条,既快又稳定

3. **PostgreSQL statement timeout**:
   - 查询时间过长会触发数据库超时
   - 合理的分页大小可以避免超时

**相关问题**:
- 如果遇到好友同步问题,参考"Q9: 好友同步时微信号切换失败?"
- 如果遇到好友同步只同步一部分,参考"Q10: 好友同步只同步了一部分?"

---

### Q12: 脚本2发送文字消息时被拆分成多条? (重要!)

**问题**: 使用脚本2发送长文字消息时,消息被拆分成多条发送,且内容不完整或乱序

**问题现象**:
- 设置了一条完整的文字消息(包含多个段落和换行)
- 发送后发现被拆分成多条消息
- 部分内容缺失或顺序混乱
- 例如:原本10个要点的消息,只发送了部分内容

**问题原因**:

**原因1: 使用page.type()逐字符输入**
- `page.type()`方法会逐字符输入文本
- 对于长文本和包含换行符的文本会有问题
- 堆雪球的输入框可能把换行符当作发送指令

**原因2: 使用innerHTML设置contenteditable元素**
- 之前误以为`#editArea`是contenteditable的div
- 实际上`#editArea`是一个**textarea元素**
- 使用`innerHTML`对textarea无效

**解决方案**:

**已在V5.8版本修复,使用正确的方式设置textarea的值**

```typescript
// ❌ 错误方式1: 逐字符输入
await page.type('#editArea', message);

// ❌ 错误方式2: 使用innerHTML
await page.evaluate((text) => {
  const editArea = document.querySelector('#editArea');
  editArea.innerHTML = text.replace(/\n/g, '<br>');
}, message);

// ✅ 正确方式: 直接设置value属性
await page.evaluate((text) => {
  const editArea = document.querySelector('#editArea') as HTMLTextAreaElement;
  if (editArea) {
    // 直接设置value属性
    editArea.value = text;

    // 触发input事件,让Vue知道内容已改变
    const inputEvent = new Event('input', { bubbles: true });
    editArea.dispatchEvent(inputEvent);

    // 触发change事件
    const changeEvent = new Event('change', { bubbles: true });
    editArea.dispatchEvent(changeEvent);
  }
}, message);
```

**验证修复**:

1. 在脚本2页面设置一条长文字消息(包含多个段落和换行)
2. 选择好友并发送
3. 检查堆雪球系统中的聊天记录
4. 应该看到完整的消息,不会被拆分

**技术要点**:

1. **textarea元素的正确操作**:
   - 使用`value`属性设置内容
   - 不要使用`innerHTML`或`textContent`
   - 需要触发`input`和`change`事件让Vue响应

2. **避免使用page.type()**:
   - 对于长文本效率低
   - 可能触发意外的键盘事件
   - 直接设置value更可靠

3. **换行符处理**:
   - textarea的换行符是`\n`
   - 不需要转换为`<br>`标签
   - 直接保留原始换行符即可

**相关问题**:
- 如果遇到Vue事件不触发,参考"Q9: 好友同步时微信号切换失败?"
- 如果遇到消息发送失败,检查堆雪球账号是否正常

---

### Q13: 脚本2发送给了未选择的好友? (重要!)

**问题**: 在脚本2页面只选择了3个好友,但系统却给更多好友发送了消息

**问题现象**:
- 前端好友列表中只勾选了3个好友
- 点击"开始发送"后,发送给了3个好友
- 但是继续发送给了其他未勾选的好友
- 后端日志显示发送给了更多好友

**问题原因**:

**前端只传递了微信号索引,没有传递选中的好友ID列表**

**详细分析**:

1. **之前的API调用**:
   ```typescript
   // ❌ 只传递了微信号索引
   fetch('/api/automation/script2/combined-reach', {
     body: JSON.stringify({
       selectedWechatAccountIndexes: [15],  // 只有微信号
       // 缺少: selectedFriendIds
     })
   });
   ```

2. **后端的处理逻辑**:
   ```typescript
   // 从数据库获取所有is_selected=true的好友
   const selectedFriends = await this.duixueqiuFriendsService.getSelectedFriends(userId);
   ```

3. **问题所在**:
   - 数据库中可能有其他好友也被标记为`is_selected=true`
   - 后端不知道前端当前页面实际选中了哪些好友
   - 导致发送给了所有数据库中标记为选中的好友

**解决方案**:

**已在V5.8版本修复,前端传递选中的好友ID列表**

**修复1: 前端传递好友ID列表**

```typescript
// script2.vue
const selectedFriendIds = friends.value
  .filter((f) => f.is_selected)
  .map((f) => f.id);

const response = await fetch('/api/automation/script2/combined-reach', {
  body: JSON.stringify({
    selectedWechatAccountIndexes: [15],
    selectedFriendIds,  // ✅ 传递选中的好友ID列表
  })
});
```

**修复2: 后端使用好友ID列表查询**

```typescript
// wechat-reach.service.ts
let selectedFriends: any[];

if (selectedFriendIds && selectedFriendIds.length > 0) {
  // ✅ 使用前端传递的好友ID列表
  const { data } = await this.supabaseService.getClient()
    .from('duixueqiu_friends')
    .select('*')
    .eq('user_id', userId)
    .in('id', selectedFriendIds);  // 只查询指定ID的好友

  selectedFriends = data || [];
} else {
  // 兼容旧逻辑: 使用数据库中is_selected=true的好友
  selectedFriends = await this.duixueqiuFriendsService.getSelectedFriends(userId);
}
```

**修复3: 添加日志验证**

```typescript
// 输出选中的好友名单
this.emitLog(`📋 选中的好友名单:`);
for (const friend of selectedFriends) {
  const friendName = friend.friend_remark || friend.friend_name;
  this.emitLog(`  - ${friendName} (${friend.wechat_account_name})`);
}
```

**验证修复**:

1. 刷新前端页面
2. 进入脚本2页面
3. 只勾选3个好友
4. 点击"开始发送"
5. 查看后端日志中的"📋 选中的好友名单"
6. 应该只显示3个好友
7. 实际发送也应该只给这3个好友发送

**技术要点**:

1. **前后端数据一致性**:
   - 前端选中的好友必须明确传递给后端
   - 不能依赖数据库中的状态标记
   - 数据库状态可能不准确或过期

2. **API设计原则**:
   - 前端应该传递完整的操作参数
   - 后端不应该猜测前端的意图
   - 使用明确的ID列表而不是状态标记

3. **向后兼容**:
   - 新增参数时保持旧逻辑可用
   - 如果没有传递新参数,使用旧逻辑
   - 避免破坏现有功能

**相关问题**:
- 如果遇到好友选择问题,检查前端的勾选状态
- 如果遇到数据库状态不一致,使用明确的ID列表

---

### Q14: 素材同步失败,提示"未找到任何好友"或"好友数据加载超时"?

**问题**: 同步视频号素材或链接素材时,Puppeteer浏览器打开后立即关闭,或者在加载页面时关闭

**问题现象**:
- 登录堆雪球后浏览器秒关闭
- 提示"未找到任何好友，无法打开素材库"
- 提示"好友数据加载超时，请检查网络或好友数量"
- 点击未分组后浏览器关闭

**问题原因**:

**原因1: 素材同步流程不完整**
- 素材同步代码缺少关键步骤:选择微信号、点击好友列表
- 直接跳到点击"未分组",导致页面状态不对

**原因2: 等待条件设置错误**
- 登录后等待"好友列表"文字出现,但页面可能不显示该文字
- 应该等待微信号列表元素出现

**原因3: 等待所有好友加载完成**
- 等待"数据加载中"消失,但10万+好友需要几分钟
- 实际上只需要等待第一批好友元素出现即可

**解决方案**:

**修复1: 完善素材同步流程** (已修复 ✅)

正确的流程应该是:
1. 登录堆雪球
2. 等待Vue应用加载(等待微信号列表出现)
3. **选择第一个微信号** ← 之前缺少
4. **点击"好友列表"标签** ← 之前缺少
5. 点击"未分组"
6. 等待好友元素出现(不等待全部加载)
7. 点击第一个好友
8. 打开素材库

**修复2: 优化等待逻辑** (已修复 ✅)

```typescript
// 登录后等待微信号列表出现(而不是等待文字)
await page.waitForFunction(
  () => {
    const items = document.querySelectorAll('.wechat-account-list > .item');
    return items.length > 0;
  },
  { timeout: 120000 }
);

// 点击未分组后,只等待好友元素出现(不等待全部加载)
await page.waitForFunction(
  () => {
    const friendElements = document.querySelectorAll('.recent-and-friend-panel-concat-item__friend');
    return friendElements.length > 0;  // 有元素就返回,不等待"数据加载中"消失
  },
  { timeout: 30000 }
);
```

**验证**:
1. 本地测试素材同步功能
2. 观察Puppeteer浏览器是否正常执行完整流程
3. 检查是否成功同步素材到数据库

**相关文件**:
- `pyq-backend/src/automation/video-material.service.ts`
- `pyq-backend/src/automation/link-material.service.ts`

---

## 🚀 性能相关

### Q9: 如何提高发布速度?

**问题**: 发布任务执行太慢

**优化方案**:

1. **调整定时任务间隔**
```typescript
// scheduler.service.ts
@Cron('*/1 * * * *')  // 每1分钟 → 每30秒
@Cron('*/30 * * * * *')
```

2. **增加Puppeteer并发数**
```typescript
// task-queue.service.ts
private maxConcurrent = 1;  // 改为 2 或 3
```

3. **优化图片处理**
```typescript
// 使用图片压缩
// 减少图片大小
```

---

### Q10: 如何减少服务器资源占用?

**问题**: 服务器CPU/内存占用过高

**优化方案**:

1. **使用headless模式**
```typescript
// puppeteer.service.ts
const browser = await puppeteer.launch({
  headless: true,  // 无头模式
  args: ['--no-sandbox', '--disable-setuid-sandbox']
});
```

2. **限制浏览器实例数**
```typescript
// 同时只运行1个Puppeteer实例
private maxConcurrent = 1;
```

3. **定期清理日志**
```bash
# 清理PM2日志
pm2 flush

# 清理Nginx日志
echo > /www/wwwlogs/access.log
```

---

## 💾 Storage相关

### Q11: 图片上传失败"new row violates row-level security policy"?

**问题**: Supabase Storage上传图片失败

**原因**: 未配置RLS策略

**解决方案**:

在Supabase控制台执行:
```sql
-- 允许所有人上传
CREATE POLICY "Allow public upload to follow-circle-images"
ON storage.objects FOR INSERT
WITH CHECK (bucket_id = 'follow-circle-images');

-- 允许所有人读取
CREATE POLICY "Allow public read from follow-circle-images"
ON storage.objects FOR SELECT
USING (bucket_id = 'follow-circle-images');
```

---

### Q12: 图片上传失败"Invalid key"?

**问题**: 文件路径包含中文字符

**原因**: Supabase Storage不支持中文路径

**解决方案**: 系统已自动修复,使用`task_时间戳`代替中文

**验证**:
```typescript
// storage.service.ts
const path = `task_${Date.now()}/image_${index}.jpg`;  // ✅ 正确
const path = `跟圈_${Date.now()}/image_${index}.jpg`;   // ❌ 错误
```

---

### Q13: Storage容量不够用怎么办?

**问题**: 免费1GB额度用完

**解决方案**:

1. **自动清理机制** (已配置)
```typescript
// scheduler.service.ts
@Cron('0 3 * * *')  // 每天凌晨3点
async cleanupOldImages() {
  // 删除7天前的图片
}
```

2. **手动清理**
```bash
# 在Supabase控制台
# Storage → follow-circle-images
# 删除旧文件夹
```

3. **升级付费版**
- Supabase Pro: $25/月
- 100GB存储空间
- 更高的API限制

---

---

## 🎨 前端相关

### Q11: 移动端页面显示不全?

**问题**: 在手机上访问公众号监控页面,只能看到左侧订阅列表,右侧文章列表看不到

**问题原因**:
- 页面使用横向布局,左侧固定320px宽度
- 手机屏幕宽度通常只有375px,右侧空间不足

**解决方案**:
- 已在V5.3版本修复
- 移动端使用垂直布局,上下排列
- 左侧订阅列表占40%高度,右侧文章列表占60%高度
- 桌面端保持原有横向布局

**强制刷新浏览器**:
```bash
# Windows/Linux
Ctrl + Shift + R

# Mac
Cmd + Shift + R
```

---

### Q12: 微信登录警告卡片无法关闭?

**问题**: 扫码登录后,警告卡片仍然显示

**常见原因**:
1. **二维码已过期** - 扫码的二维码已经过期,需要刷新
2. **未在手机上确认** - 扫码后没有在手机上点击"确认登录"
3. **扫码后等待时间过长** - 超过有效期导致二维码失效

**解决方案** (V5.3.1版本已优化):

1. **自动刷新二维码**
   - 系统检测到二维码过期后会自动刷新
   - 无需手动操作,重新扫码即可

2. **快捷登录按钮**
   - 点击警告卡片上的 **"刷新二维码"** 按钮
   - 自动跳转到登录页面并刷新二维码
   - 扫码后在手机上点击"确认登录"

3. **手动关闭警告**
   - 点击警告卡片右侧的 **✕** 按钮暂时关闭
   - 登录过期时会自动重新显示

**验证登录成功**:
```javascript
// 打开浏览器控制台(F12),查看以下日志:
🎉 登录成功！正在刷新数据...
✅ wechatLoginStatus已更新: {
  isLoggedIn: true,    // 登录成功
  checked: true,
  message: "微信公众平台已登录"
}
```

**注意事项**:
- ⚠️ 扫码后必须在手机上点击"确认登录"
- ⚠️ 二维码有效期约2分钟,过期会自动刷新
- ⚠️ 如果一直显示"已过期",请检查网络连接

---

### Q16: 从公众号监控页面切换到其他页面时显示空白? (重要!)

**问题**: 访问公众号监控页面后,切换到任何其他页面都显示空白

**问题现象**:
- 直接访问任何页面都正常显示
- 访问公众号监控页面后,切换到其他页面(Script1/Script2/手动模式等)全部空白
- 浏览器Elements标签显示全是`<!--v-if-->`注释
- 控制台没有JavaScript错误
- 刷新浏览器后恢复正常

**问题原因**:

**Vue Transition组件的`mode="out-in"`导致页面切换卡住**

1. **Transition动画机制**: Vben Admin框架默认使用`<Transition mode="out-in">`实现页面切换动画
2. **out-in模式**: 先等待旧组件完全退出(out),再让新组件进入(in)
3. **公众号监控页面复杂**: 该页面包含大量数据(订阅列表、文章列表、图片等),DOM结构复杂
4. **退出动画卡住**: 公众号监控页面的退出动画因为DOM复杂度高而卡住,无法完成
5. **新页面无法进入**: 由于旧页面退出动画未完成,新页面永远不会进入,导致空白

**技术细节**:
```vue
<!-- Vben Admin的默认配置 -->
<Transition
  name="fade-slide"
  mode="out-in"  <!-- ⚠️ 问题根源 -->
  appear
>
  <component :is="Component" />
</Transition>
```

**解决方案**:

**永久禁用Transition动画** (已在V5.6版本修复)

修改文件: `packages/effects/layouts/src/basic/content/content.vue`

```typescript
// 禁用keep-alive,避免页面缓存导致的状态问题
const keepAlive = false;

// 禁用Transition动画,避免mode="out-in"导致页面切换卡住
const enableTransition = false;

/**
 * 是否使用动画
 * 已禁用动画,避免Transition的mode="out-in"导致页面切换时卡住
 */
const getEnabledTransition = computed(() => {
  // 永久禁用动画
  if (!enableTransition) {
    return false;
  }
  const { transition } = preferences;
  const transitionName = transition.name;
  return transitionName && transition.enable;
});
```

**为什么选择禁用动画?**

1. ✅ **彻底解决问题** - 不会再出现页面切换卡住的情况
2. ✅ **性能更好** - 页面切换更快,无需等待动画
3. ✅ **适合后台系统** - 管理后台不需要华丽的动画效果
4. ✅ **简单可靠** - 不需要复杂的动画配置和调试

**其他可选方案** (未采用):

**方案2: 修改Transition的mode**
```vue
<!-- 改为in-out或不设置mode -->
<Transition name="fade-slide" mode="in-out">
  <component :is="Component" />
</Transition>
```
- 缺点: 可能会有短暂的两个页面同时显示

**方案3: 只禁用公众号监控页面的动画**
```typescript
// 在路由配置中
{
  path: '/wechat/subscription',
  meta: {
    transition: false  // 禁用该页面的动画
  }
}
```
- 缺点: 需要修改路由配置,不够彻底

**验证修复**:

```bash
# 1. 刷新浏览器 (Ctrl+Shift+R 或 Cmd+Shift+R)
# 2. 访问公众号监控页面
# 3. 切换到Script1/Script2等其他页面
# 4. 页面应该立即显示,无需等待动画
```

**调试技巧**:

如果问题仍然存在,检查以下内容:

```bash
# 1. 确认enableTransition已设置为false
cat packages/effects/layouts/src/basic/content/content.vue | grep "enableTransition"

# 2. 确认前端已重新编译
cd pyq-frontend-vben
pnpm build:antd

# 3. 确认浏览器已清除缓存
# 按 Ctrl+Shift+R 强制刷新
```

**最佳实践**:

- ✅ **后台管理系统建议禁用页面切换动画** - 提升性能和稳定性
- ✅ **复杂页面避免使用out-in模式** - 容易导致动画卡住
- ✅ **如果必须使用动画,选择in-out或不设置mode** - 避免等待旧页面退出
- ✅ **定期测试页面切换** - 确保所有页面都能正常切换

**相关问题**:

- 如果遇到keep-alive相关问题,参考下方的"Vue Router keep-alive最佳实践"
- 如果遇到WebSocket断开问题,检查`onActivated`钩子是否正确实现

---

### Q17: Vue Router keep-alive最佳实践

**问题**: 使用keep-alive缓存页面时,页面状态不正确

**问题现象**:
- 从其他页面切换回来时,数据没有更新
- WebSocket连接断开
- 页面显示空白或错误

**解决方案**:

**1. 正确的onActivated实现**:
```typescript
// ✅ 正确的实现
onActivated(async () => {
  console.log('🔄 页面已激活 (onActivated)');

  try {
    // 必须使用await等待异步操作完成
    await loadData();

    // 检查WebSocket连接状态
    if (!socket.value?.connected) {
      console.log('🔌 WebSocket未连接,尝试重新连接...');
      connectWebSocket();
    }

    console.log('✅ 页面数据加载完成');
  } catch (error) {
    console.error('❌ 页面激活时加载数据失败:', error);
    message.error('加载数据失败,请刷新页面重试');
  }
});
```

**2. 错误的实现示例**:
```typescript
// ❌ 错误: 没有async/await
onActivated(() => {
  loadData();  // 异步函数但没有await
});

// ❌ 错误: 没有错误处理
onActivated(async () => {
  await loadData();  // 如果出错,页面会崩溃
  // 缺少try-catch
});
```

**3. 关键要点**:
- ✅ **onActivated必须是async函数** - 确保可以使用await
- ✅ **必须await所有异步操作** - 确保数据加载完成
- ✅ **必须添加try-catch** - 防止错误导致页面崩溃
- ✅ **检查WebSocket连接** - 页面激活时重新连接
- ✅ **添加日志** - 便于调试和排查问题

**注意**: 本项目已禁用keep-alive,无需担心此问题。

---

## 💻 本地开发相关

### Q18: 本地测试时Puppeteer浏览器窗口不显示? (重要!)

**问题**: 在本地Mac上测试好友同步功能时,无法看到Puppeteer浏览器窗口

**问题现象**:
- 访问localhost:4173(本地前端)
- 点击"同步好友"按钮
- 前端显示正在同步,控制台收到WebSocket进度消息
- 但是Mac上没有Chrome/Chromium浏览器窗口弹出
- 无法看到Puppeteer自动化操作的过程

**问题根源**:

**本地前端的API请求被代理到了生产服务器,而不是本地后端!**

**详细分析**:

1. **Vite开发服务器的代理配置**:
   ```typescript
   // vite.config.mts
   server: {
     proxy: {
       '/api': {
         target: 'https://autochat.lfdhk.com',  // ← 指向生产服务器!
         ws: true,
       },
     },
   }
   ```

2. **请求流程**:
   - ✅ 用户访问 `localhost:4173` (本地前端)
   - ✅ 前端发送请求到 `/api/automation/friends/sync`
   - ❌ Vite代理将请求转发到 `https://autochat.lfdhk.com/api/automation/friends/sync` (生产服务器)
   - ❌ Puppeteer在云端服务器(124.223.35.102)运行
   - ❌ 浏览器窗口在云端服务器上打开,本地Mac看不到

3. **为什么会这样配置?**:
   - 生产环境需要前端访问生产服务器的API
   - 开发时忘记切换回本地后端
   - Vite配置文件同时用于开发和生产环境

**解决方案**:

**修改Vite配置,将API代理指向本地后端**

**步骤1: 修改vite.config.mts**

```bash
# 编辑文件
vim 朋友圈自动发布系统/pyq-frontend-vben/apps/web-antd/vite.config.mts
```

```typescript
server: {
  proxy: {
    '/api': {
      changeOrigin: true,
      // 代理到本地NestJS后端 (用于本地测试,可以看到Puppeteer浏览器窗口)
      target: 'http://localhost:3000',  // ← 改为本地后端
      ws: true,
    },
    '/socket.io': {
      changeOrigin: true,
      target: 'http://localhost:3000',  // ← 改为本地后端
      ws: true,
    },
  },
},
```

**步骤2: 重启前端预览服务**

```bash
# 停止当前服务 (Ctrl+C)
# 重新启动
cd 朋友圈自动发布系统/pyq-frontend-vben/apps/web-antd
pnpm vite preview
```

**步骤3: 确保本地后端正在运行**

```bash
# 检查本地后端是否运行
curl http://localhost:3000/api/health

# 如果没有运行,启动本地后端
cd 朋友圈自动发布系统/pyq-backend
npm run start:dev
```

**步骤4: 测试Puppeteer浏览器窗口**

1. 刷新浏览器页面 (Cmd+R)
2. 进入Script2页面
3. 选择一个微信号
4. 点击"同步选中"按钮
5. **应该会弹出Chrome/Chromium浏览器窗口**
6. **可以看到Puppeteer自动登录、切换微信号、滚动加载好友等操作**

**验证成功的标志**:

```bash
# 本地后端日志应该显示:
[DuixueqiuFriendsService] 环境变量 PUPPETEER_HEADLESS = false
[DuixueqiuFriendsService] 计算后的 headless = false
[DuixueqiuFriendsService] 🔐 开始登录堆雪球客服端...
[DuixueqiuFriendsService] ✅ 登录成功
```

**常见问题**:

**Q: 修改后还是看不到浏览器窗口?**

A: 检查以下几点:
1. 确认Vite配置已修改并保存
2. 确认前端预览服务已重启
3. 确认本地后端正在运行(localhost:3000)
4. 确认浏览器已刷新(Cmd+R)
5. 检查本地后端的`.env`文件中`PUPPETEER_HEADLESS=false`

**Q: 浏览器窗口打开后立即关闭?**

A: 这是页面加载超时导致的,已在V5.7版本修复:
- 将超时时间从90秒增加到180秒
- 等待Vue渲染完成的时间从120秒增加到180秒

**Q: 如何切换回生产服务器?**

A: 修改vite.config.mts,将target改回`https://autochat.lfdhk.com`,然后重启前端服务

**最佳实践**:

1. **本地开发时使用本地后端**:
   - 可以看到Puppeteer浏览器窗口
   - 可以调试后端代码
   - 不会影响生产环境

2. **部署到生产时使用生产后端**:
   - 前端直接访问生产API
   - 无需修改配置

3. **使用环境变量区分**:
   ```typescript
   // 更好的方案:根据环境自动切换
   const target = process.env.NODE_ENV === 'production'
     ? 'https://autochat.lfdhk.com'
     : 'http://localhost:3000';
   ```

**相关问题**:
- 如果遇到Puppeteer加载超时,参考下方的"Puppeteer页面加载超时"
- 如果遇到环境变量不生效,参考"修改.env文件后必须重启服务"

---

### Q19: 修改.env文件后环境变量不生效?

**问题**: 修改了`.env`文件中的配置,但是后端仍然使用旧的值

**问题现象**:
- 修改了`PUPPETEER_HEADLESS=false`
- 但是后端日志显示`headless=true`
- Puppeteer仍然以无头模式运行

**问题原因**:

**NestJS的watch模式不会自动重新加载`.env`文件!**

**详细分析**:

1. **NestJS的watch模式**:
   ```bash
   npm run start:dev
   # 使用nest start --watch
   ```

2. **watch模式的行为**:
   - ✅ 自动重新加载TypeScript代码文件(`.ts`, `.js`)
   - ❌ **不会**自动重新加载环境变量文件(`.env`)

3. **为什么不重新加载?**:
   - `.env`文件在应用启动时只读取一次
   - 环境变量加载到`process.env`中
   - watch模式只监听代码文件变化,不监听配置文件

**解决方案**:

**修改`.env`文件后必须手动重启后端服务!**

**步骤1: 停止后端服务**

```bash
# 在运行npm run start:dev的终端按 Ctrl+C
```

**步骤2: 重新启动后端服务**

```bash
cd 朋友圈自动发布系统/pyq-backend
npm run start:dev
```

**步骤3: 验证环境变量已加载**

```bash
# 查看后端日志
# 应该看到:
[DuixueqiuFriendsService] 环境变量 PUPPETEER_HEADLESS = false
[DuixueqiuFriendsService] 计算后的 headless = false
```

**常见的需要重启的场景**:

1. **修改Puppeteer配置**:
   ```bash
   PUPPETEER_HEADLESS=false  # 需要重启
   ```

2. **修改数据库连接**:
   ```bash
   SUPABASE_URL=xxx  # 需要重启
   SUPABASE_KEY=xxx  # 需要重启
   ```

3. **修改堆雪球账号**:
   ```bash
   DUIXUEQIU_USERNAME=xxx  # 需要重启
   DUIXUEQIU_PASSWORD=xxx  # 需要重启
   ```

4. **修改Coze配置**:
   ```bash
   COZE_API_KEY=xxx  # 需要重启
   COZE_WORKFLOW_ID=xxx  # 需要重启
   ```

**不需要重启的场景**:

1. **修改TypeScript代码** - watch模式自动重新编译
2. **修改前端代码** - Vite自动热更新
3. **修改数据库数据** - 直接生效

**最佳实践**:

1. **修改.env文件后立即重启服务** - 避免忘记重启导致配置不生效
2. **使用日志验证配置** - 启动后检查日志确认配置正确
3. **生产环境使用PM2** - PM2重启会自动重新加载环境变量

**生产环境重启**:

```bash
# SSH到服务器
ssh root@124.223.35.102

# 重启PM2服务
pm2 restart pyq-backend

# 查看日志验证
pm2 logs pyq-backend --lines 50
```

---

### Q20: Puppeteer页面加载超时导致浏览器关闭?

**问题**: Puppeteer浏览器打开后,完成登录,但在加载页面时浏览器突然关闭

**问题现象**:
- ✅ Puppeteer浏览器窗口成功打开
- ✅ 成功登录堆雪球系统
- ⏳ 开始加载微信号列表页面
- ❌ 等待一段时间后,浏览器突然关闭
- ❌ 后端日志显示超时错误

**问题原因**:

**堆雪球系统使用Vue.js框架,页面渲染需要较长时间,超过了Puppeteer的默认超时时间**

**详细分析**:

1. **堆雪球页面加载过程**:
   - 加载HTML文档 (1-2秒)
   - 加载Vue.js框架 (2-3秒)
   - Vue渲染微信号列表 (10-60秒,取决于微信号数量和好友数量)
   - 加载好友数据 (可能需要额外时间)

2. **之前的超时配置**:
   ```typescript
   await page.waitForSelector('.wechat-account-list', { timeout: 90000 });  // 90秒
   const maxWaitForVue = 120000;  // 120秒
   ```

3. **为什么会超时?**:
   - 微信号数量多(17个)
   - 每个微信号的好友数量多(最多9948个)
   - Vue需要渲染大量DOM元素
   - 网络延迟可能导致加载更慢

**解决方案**:

**已在V5.7版本修复,将超时时间增加到180秒**

**修改内容**:

```typescript
// duixueqiu-friends.service.ts

// 修复前
await page.waitForSelector('.wechat-account-list', { timeout: 90000 });  // 90秒
const maxWaitForVue = 120000;  // 120秒

// 修复后
await page.waitForSelector('.wechat-account-list', { timeout: 180000 });  // 180秒
const maxWaitForVue = 180000;  // 180秒
```

**验证修复**:

```bash
# 1. 确认本地后端已重启(加载最新代码)
cd 朋友圈自动发布系统/pyq-backend
npm run start:dev

# 2. 测试好友同步
# 访问 localhost:4173
# 进入Script2页面
# 选择一个微信号
# 点击"同步选中"

# 3. 观察后端日志
# 应该看到:
[DuixueqiuFriendsService] 等待微信号列表容器出现(增加到180秒,因为Vue渲染很慢)
[DuixueqiuFriendsService] ⏳ Vue仍在渲染... (已等待10.0秒)
[DuixueqiuFriendsService] ⏳ Vue仍在渲染... (已等待20.0秒)
...
[DuixueqiuFriendsService] ✅ Vue已渲染完成! 找到 17 个微信号 (耗时87.1秒)
```

**如果仍然超时**:

**方案1: 进一步增加超时时间**

```typescript
// 修改为300秒(5分钟)
await page.waitForSelector('.wechat-account-list', { timeout: 300000 });
const maxWaitForVue = 300000;
```

**方案2: 优化堆雪球系统**

- 减少微信号数量
- 减少每个微信号的好友数量
- 优化网络连接

**方案3: 使用更快的服务器**

- 本地Mac性能通常比云端服务器好
- 本地测试时加载速度更快

**最佳实践**:

1. **本地测试时使用较短的超时时间** (90-120秒)
2. **生产环境使用较长的超时时间** (180-300秒)
3. **添加详细的日志** - 便于排查超时原因
4. **使用智能等待** - 不要硬编码延迟,使用`waitForSelector`

**相关配置**:

```typescript
// 其他可能需要调整的超时配置

// 登录超时
await page.waitForNavigation({ timeout: 30000 });  // 30秒

// 点击后等待
await page.waitForSelector('.friend-list', { timeout: 60000 });  // 60秒

// 滚动加载超时
const maxScrollAttempts = 5000;  // 最大滚动5000次
const stableCount = 100;  // 连续100次不变才停止
```

---

## 🔥 重大问题深度分析

### 定时任务修复完整方案

#### 📋 问题描述

**问题**: 公众号监控的定时同步任务不生效,文章列表没有自动获取到最新的文章

**影响**: 用户需要手动点击"同步"按钮才能获取最新文章,无法实现自动化监控

**发现时间**: 2025-11-08

---

#### 🔍 问题分析

**根本原因**:

在 `SchedulerService` 的构造函数中调用了异步方法 `initializeSyncTask()`,但没有使用 `await` 等待其完成。

**问题代码**:
```typescript
constructor(...) {
  // ❌ 错误: 在构造函数中调用异步方法但不等待
  this.initializeSyncTask();

  this.storageService.ensureBucketExists().catch((error) => {
    this.logger.error('初始化Storage Bucket失败', error);
  });
}
```

**为什么会导致问题?**

1. **构造函数不支持异步**: TypeScript/JavaScript的构造函数不能是异步的
2. **初始化可能失败**: 如果 `initializeSyncTask()` 执行过程中出错,错误会被静默忽略
3. **时序问题**: 定时任务可能在依赖服务初始化完成之前就尝试启动
4. **NestJS反模式**: 违反了NestJS的最佳实践,应该使用生命周期钩子

---

#### ✅ 修复方案

**1. 使用 OnModuleInit 生命周期钩子**:

```typescript
import { Injectable, Logger, Inject, OnModuleInit } from '@nestjs/common';

@Injectable()
export class SchedulerService implements OnModuleInit {
  constructor(...) {
    // ✅ 构造函数只做依赖注入,不执行异步操作
  }

  /**
   * 模块初始化时执行
   */
  async onModuleInit() {
    this.logger.log('📋 SchedulerService 模块初始化开始...');

    // 初始化定时同步任务
    await this.initializeSyncTask();

    // 确保Storage Bucket存在
    try {
      await this.storageService.ensureBucketExists();
      this.logger.log('✅ Storage Bucket 初始化成功');
    } catch (error) {
      this.logger.error('❌ 初始化Storage Bucket失败', error);
    }

    this.logger.log('✅ SchedulerService 模块初始化完成');
  }
}
```

**2. 增强错误处理和日志**:

```typescript
async initializeSyncTask() {
  try {
    this.logger.log('🔧 开始初始化文章同步任务...');

    const intervalMinutes = await this.configService.getSyncInterval();
    this.logger.log(`⏰ 从配置中获取同步间隔: ${intervalMinutes} 分钟`);

    await this.restartSyncTask(intervalMinutes);

    this.logger.log('✅ 文章同步任务初始化成功');
  } catch (error) {
    this.logger.error(`❌ 初始化同步任务失败: ${error.message}`, error.stack);

    // 使用默认间隔重试
    this.logger.log('🔄 尝试使用默认间隔(30分钟)重新初始化...');
    try {
      await this.restartSyncTask(30);
      this.logger.log('✅ 使用默认间隔初始化成功');
    } catch (retryError) {
      this.logger.error('❌ 重试失败,定时任务无法启动', retryError);
    }
  }
}
```

**3. 优化日志输出**:

```typescript
@Cron('*/30 * * * *')  // 每30分钟执行一次
async syncArticles() {
  this.logger.log('🔄 开始执行定时同步任务...');

  try {
    const result = await this.wechatArticleService.syncAllArticles();
    this.logger.log(`✅ 定时同步完成: 新增 ${result.newCount} 篇文章`);
  } catch (error) {
    this.logger.error('❌ 定时同步失败', error);
  }
}
```

---

#### 🚀 部署步骤

**方法一: 使用自动部署脚本 (推荐)**:

```bash
# 在本地执行
cd 朋友圈自动发布系统
./deploy.sh
```

**方法二: 手动部署**:

**1. 本地编译**:
```bash
cd pyq-backend
npm run build
```

**2. 上传文件到服务器**:
```bash
scp -r dist root@124.223.35.102:/www/wwwroot/pyq-backend/pyq-backend/
```

**3. 重启服务**:
```bash
ssh root@124.223.35.102
cd /www/wwwroot/pyq-backend/pyq-backend
pm2 restart pyq-backend
```

**4. 查看日志**:
```bash
pm2 logs pyq-backend
```

---

#### 🔍 验证修复

**1. 检查服务启动日志**:
```bash
pm2 logs pyq-backend --lines 50
```

应该看到:
```
📋 SchedulerService 模块初始化开始...
🔧 开始初始化文章同步任务...
⏰ 从配置中获取同步间隔: 30 分钟
✅ 文章同步任务初始化成功
✅ Storage Bucket 初始化成功
✅ SchedulerService 模块初始化完成
```

**2. 等待30分钟后检查**:
```bash
pm2 logs pyq-backend | grep "定时同步"
```

应该看到:
```
🔄 开始执行定时同步任务...
✅ 定时同步完成: 新增 X 篇文章
```

**3. 检查文章列表**:
- 访问前端页面
- 进入"公众号监控"
- 查看文章列表是否有新文章

---

#### 📊 实时监控命令

```bash
# 实时查看日志
pm2 logs pyq-backend --lines 100

# 只看定时任务相关日志
pm2 logs pyq-backend | grep "定时\|同步\|Scheduler"

# 查看进程状态
pm2 show pyq-backend

# 查看内存和CPU使用
pm2 monit
```

---

## 🔗 相关文档

- [部署与配置指南](./部署与配置指南.md) - 完整部署流程
- [数据库文档](./数据库结构文档.md) - 数据库结构和配置
- [服务器常用命令](./服务器常用命令.md) - 运维命令参考
- [危险操作警告](./危险操作警告.md) - 禁止的操作

---

[← 返回README](./README.md)

---

**最后更新**: 2025-11-24
**维护者**: 小牛马

